"""
Name: Richard Lim
Course: CSCI 3725
Assignment: M1
Date: 09-16-2025
Description: Utility functions for Markov Chain and Block Iterator
Bugs: None known
"""

import numpy as np
import itertools
import random


class MarkovChain:
    def __init__(self, pad : bool=True, order: int=1):
        """
        A simple Markov Chain implementation for sequences of states.

        Args:
            pad: bool: Whether to pad the sequences with None at the start and end.
            order: int: The order of the Markov Chain (number of previous states to consider).
        """
        self.order = order
        self.transitions = {}
        self.states = set()
        self.pad = pad
        self.generated_sequence = []

    def learn(self, sequences: list[list]):
        """
        Learns the transition probabilities from the given sequences.

        Args:
            sequences: list of list: A list of sequences, where each sequence is a list of states.

        """
        for seq in sequences:
            self.states.update(seq)
            if self.pad:
                seq = [None]*self.order + seq + [None]*self.order
            for i in range(len(seq) - self.order):
                state = tuple(seq[i : i + self.order])
                next_state = seq[i + self.order]
                self.transitions[state] = self.transitions.get(state, {})
                self.transitions[state][next_state] = self.transitions[state].get(next_state, 0) + 1

        # Normalize probabilities
        self.probs = {}
        for state, next_states in self.transitions.items():
            total = sum(next_states.values())
            self.probs[state] = {k: v/total for k, v in next_states.items()}

    def generate_next(self, current_state=None):
        """
        Generate the next state based on the current state. Appends the next state to the generated sequence.

        Args:
            current_state: list: The current state to base the next state on. If None, use the last 'order' states from the generated sequence.
        Returns:
            The next state generated by the Markov Chain.
        """

        # By default, use the last 'order' states from the generated sequence, padding None if necessary
        if current_state is None:
            current_state = self.generated_sequence[-min(self.order, len(self.generated_sequence)):]
            while len(current_state) < self.order:
                current_state.insert(0, None)
        next_states = self.probs.get(tuple(current_state), {None: 1.0}) # if state not found, return end token
        next_state = np.random.choice(list(next_states.keys()), p=list(next_states.values()))
        if next_state is not None:
            self.generated_sequence.append(next_state)
            return next_state
        else:
            return self.generate_next([None]*self.order) # resample from start tokens if end token is reached (i.e. None)


class BlockIterator:
    def __init__(self, shape, block_size=1, axis=0, pattern=None, seed=None):
        """
        An iterator that yields the top-left corner of each block in an image.

        Args:
            shape: tuple of (height, width, ...) of the image
            block_size: size of the blocks to iterate over
            axis: 0 for row-wise, 1 for column-wise
            pattern:
            seed: seed for random pattern (only applicable if pattern = 'random', only used by self.copy() or for debugging)
        """

        self.shape = shape
        self.block_size = block_size
        if shape[0] % block_size != 0 or shape[1] % block_size != 0:
            raise ValueError("shape[0] and shape[1] must be divisible by block_size")
        self.axis = axis
        self.pattern = pattern
        if pattern == 'random' and seed is None:
            seed = random.randint(0, 2 ** 32 - 1)
        self.seed = seed

    def __iter__(self):
        """
        An iterator over the top-left corners of each block in the image.
        """
        x_start, x_end = 0, self.shape[0]
        y_start, y_end = 0, self.shape[1]
        if self.block_size < 0:
            x_start, x_end = self.shape[0] - 1, -1
            y_start, y_end = self.shape[1] - 1, -1

        x = range(x_start, x_end, self.block_size)
        y = range(y_start, y_end, self.block_size)
        if self.axis == 1:
            x, y = y, x
        corners = list(itertools.product(x, y))
        if self.pattern == 'random':
            random.shuffle(corners)
        return corners.__iter__()

    def copy(self):
        """
        Creates a copy of the BlockIterator with the same parameters. Preserves the random seed if applicable.
        """
        return BlockIterator(self.shape, self.block_size, self.axis, self.pattern, self.seed)

    def __repr__(self):
        return f"BlockIterator(shape={self.shape}, block_size={self.block_size}, axis={self.axis}, pattern={self.pattern}, seed={self.seed})"

    def __str__(self):
        arrangement = 'random' if self.pattern == 'random' else ('row' if self.axis == 0 else 'col')
        return f"BlockIterator({arrangement}, block_size={self.block_size})"


class Block:
    """
    A wrapper class for a numpy array to make it hashable and comparable for use in the Markov Chain.
    """
    def __init__(self, arr: np.ndarray):
        """
        Initialize the Block with a numpy array.
        """
        self.arr = arr

    def __hash__(self):
        """
        Hash a flattened version of the array for use in sets and as dictionary keys. It is unique because all blocks
        are the same size and shape.
        """
        return hash(tuple(self.arr.flatten()))

    def __eq__(self, other):
        """
        Compare two blocks for equality by comparing their flattened arrays.
        """
        return tuple(self.arr.flatten()) == tuple(other.arr.flatten())

    def __repr__(self):
        """
        A string representation of the Block for debugging.
        """
        return f"Block({self.arr})"

    def __str__(self):
        """
        A concise string representation of the Block.
        """
        return f"Block(shape={self.arr.shape})"
